一、散列表
        1、散列表：最有用的基本数据结构之一。（在我看来，散列表=字典。不，它就是字典。）
                散列表的内部机制：
                    a)实现
                    b)冲突
                    c)散列函数
        2、键值对：键是唯一的，有且仅能有一个，而值必须绑定在唯一的键上。
        3、一致和不一致的区别在于：给同样的一个键，总会返回同一个值，不会更改。每个值都有它相对应的唯一索引。
        4、代码：
                def check_voter(name):
                    if voted.get(name):
                        print("kick them out!")
                    else:
                        voted[name] = True
                        print("let them vote!")
           解析：传入来投票的人的名字，如果名字在散列表中，拒绝；否则，先将该人的name
           与True成一对键值对添加到字典中，然后统一其投票。
二、缓存
        1、工作原理：网站将数据记住，而不再重新计算。
        2、缓存的优点：
            a)需要做的工作更少了。
        3、散列表适用于
            a)模拟映射关系；
            b)防止重复；
            c)缓存/记住数据，以免服务器再通过处理来生成它们。
三、冲突
        1、冲突（collision）：给两个键分配的位置相同。
        2、解决冲突的办法：最简单的是如果两个键映射到了同一个位置，就在这个位置存储一个链表。
四、性能
        1、在最糟情况下，散列表所有操作的运行时间都为O(n)。
        2、避免冲突
                a)较低的填装因子；
                b)良好的散列函数。
        3、装填因子：一旦填装因子大于0.7，就调整散列表的长度。
五、小结
        1、你可以结合散列函数和数组来创建散列表。
        2、冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。
        3、散列表的查找、插入和删除速度都非常快。
        4、散列表适合用于模拟映射关系。
        5、一旦填装因子超过0.7，就该调整散列表的长度。
        6、散列表可用于缓存数据（例如，在Web服务器上）。
        7、散列表非常适合用于防止重复。
