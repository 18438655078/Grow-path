一、分而治之(D&C)：一种著名的递归式问题解决办法。
        工作原理：
                a)找出简单的基线条件；
                b)确定瑞和缩小问题的规模，使其符合基线条件。
        D&C并不是一种算法，而是解决问题的思路。
        提示：编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。陷入困境时，请检查基线条件是不是这样的。
        1、欧几里得算法：适用于这小块地的最大方块，也式适用于整块地的最大方块。
        问题：
            1、请编写前述sum函数的代码。
                def sum(list):
                    if list == []:
                        return 0
                    return list[0] + sum(list[1:])
                解析：当列表为空时返回0，否则返回列表第一个元素+调用递归sum()
            2、编写一个递归函数来计算列表包含的元素数。
                def count(list):
                    if list == []:
                        return 0
                    return 1 + count(list[1:])
                解析：当列表为空时返回0，否则递归调用count函数并传入从1开始的列表。
            3、找出列表中最大的数字。
                def max(list):
                    if len(list) == 2:
                        return list[0] if list[0] > list[1] else list[1]
                    sub_max = max(list[1:])
                    return list[0] if list[0] > sub_max else sub_max
                解析：当列表只剩两个元素的时候进行判断，哪一个大返回那一个。
                      否则令sub_max等于max(list[1:])返回的值，
                      然后对列表中第一个元素和sub_max比较，返回较大的那个。
            4、还记得第1章介绍的二分查找吗？它也是一种分而治之算法。你能找出二分查找算法的基线条件和递归条件吗？
                基线条件：找到的值等于猜的值。即列表中只有一个值。如果没找到证明不存在。
                递归条件：如果小了返回大的一半，如果大了返回小的一半。
二、快速排序：是一种常用的排序算法，比选择排序快得多。而且快速排序也使用了D&C。
        1、排序步骤：
                (1) 选择基准值。
                (2) 将数组分成两个子数组：小于基准值的元素和大于基准值的元素。
                (3) 对这两个子数组进行快速排序。
        2、快速排序代码：
                # 快速排序
                def quicksort(array):
                    if len(array) < 2:
                        return array    # 基线条件
                    else:
                        pivot = array[0]    # 递归条件
                        less = [i for i in array[1:] if i <= pivot]    # 小于基准值的元素列表
                        greater = [i for i in array[1:] if i > pivot]    # 大于基准值的元素列表 
                        return quicksort(less) + [pivot] + quicksort(greater)
                print(quicksort([10, 5, 2, 3]))
        3、大O时间： O(n log n)
                1、快速排序的情况比较棘手，在最糟情况下，其运行时间为O(n2)。与选择排序一样慢，但这是最糟情况。
                2、有一种名为合并排序（merge sort）的排序算法，其运行时间也为O(n log n)
        4、平均情况和最糟情况：
                a)平均情况就是最优和最糟的平均值
                b)最糟情况就是对于去基准值时总是一边空另一边满的情况，调用高度为n
                c)大O时间是：调用高度时间 * 层内时间 = O()时间
三、小结
        a)D&C将问题逐步分解。使用D&C处理列表时，基线条件很可能是空数组或只包含一个元素的数组。
        b)实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为O(n log n)。
        c)大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。
        d)比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时，O(log n)的速度比O(n)快得多。 
